<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Triptych Scroll</title>

  <!-- link your updated CSS -->
  <link rel="stylesheet" href="triptych.css" />
</head>
<body>
  <!-- 1. The 16∶9 wrapper -->
  <div class="wrapper">
    <!-- 2. The flex row -->
    <div class="triple-scroll-container">
      <!-- LEFT column -->
      <div class="scroll-column">
        <img src="first-fish-left.png" alt="Fish 1 Left">
        <img src="second-fish-left.png" alt="Fish 2 Left">
        <img src="third-fish-left.png" alt="Fish 3 Left">
      </div>

      <!-- MIDDLE column -->
      <div class="scroll-column">
        <img src="first-fish-middle.png" alt="Fish 1 Middle">
        <img src="second-fish-middle.png" alt="Fish 2 Middle">
        <img src="third-fish-middle.png" alt="Fish 3 Middle">
      </div>

      <!-- RIGHT column -->
      <div class="scroll-column">
        <img src="first-fish-right.png" alt="Fish 1 Right">
        <img src="second-fish-right.png" alt="Fish 2 Right">
        <img src="third-fish-right.png" alt="Fish 3 Right">
      </div>
    </div>
  </div>

  <!-- 3. The “infinite” scroll script -->
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      // For each of the three columns, do these steps:
      document.querySelectorAll('.scroll-column').forEach(col => {
        // a) Capture the column’s current scrollHeight (this is the height of ONE set of images).
        //    Because our wrapper is 16∶9 and each image is rendered to exactly that height,
        //    col.scrollHeight right now = wrapperHeight.
        const singleSetHeight = col.scrollHeight;

        // b) Duplicate (clone) every child node (each <img>) and append them below.
        //    Now each column has two back-to-back sets of fish: [1,2,3] + [1,2,3].
        const originalContent = col.innerHTML;
        col.innerHTML += originalContent;

        // c) Add bottom padding exactly equal to one “column height” so the user never sees blank space.
        //    When you scroll past the first two sets, there’s always more fish below.
        col.style.paddingBottom = singleSetHeight + 'px';

        // d) Immediately jump the column’s scrollTop to the start of the SECOND copy:
        //    i.e. scrollTop = singleSetHeight → so you begin in the middle.
        col.scrollTop = singleSetHeight;

        // e) Listen for scroll events and “teleport” if you scroll too far up or down.
        col.addEventListener('scroll', () => {
          // If you scroll *below* the second copy’s end (i.e. past 2× singleSetHeight),
          // jump back up by singleSetHeight so you’re again in the middle copy.
          if (col.scrollTop >= singleSetHeight * 2) {
            col.scrollTop -= singleSetHeight;
          }
          // If you scroll *above* the very start (scrollTop ≤ 0),
          // jump down by singleSetHeight to land in the middle copy.
          else if (col.scrollTop <= 0) {
            col.scrollTop += singleSetHeight;
          }
        });
      });
    });
  </script>
</body>
</html>
